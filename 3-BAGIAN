import customtkinter
from tkinter import messagebox
from collections import OrderedDict
import base64
import hashlib
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad

# ==============================================================================
# BAGIAN 1: FUNGSI INTI CIPHER
# ==============================================================================

# --- 1. PERSIAPAN TEKS (UNTUK PLAYFAIR) ---
# Fungsi ini membersihkan dan memformat teks mentah menjadi pasangan huruf (digraf)
# yang siap untuk dienkripsi dengan algoritma Playfair.
def prepare_playfair_text(text: str) -> list[str]:
    """Mempersiapkan plaintext untuk enkripsi Playfair."""
    # Bersihkan teks: ubah ke huruf besar, hapus non-alfabet, ganti J dengan I
    clean_text = list("".join(filter(str.isalpha, text.upper().replace('J', 'I'))))
    
    if not clean_text:
        return []
    
    # Sisipkan 'X' di antara huruf kembar yang bersebelahan
    i = 0
    while i < len(clean_text) - 1:
        if clean_text[i] == clean_text[i+1]:
            clean_text.insert(i + 1, 'X')
        i += 2
        
    # Tambahkan 'X' di akhir jika jumlah huruf ganjil
    if len(clean_text) % 2 != 0:
        clean_text.append('X')
        
    # Gabungkan kembali dan pecah menjadi pasangan huruf (digraf)
    final_text = "".join(clean_text)
    return [final_text[j:j+2] for j in range(0, len(final_text), 2)]


# --- 2. PLAYFAIR CIPHER (SUBSTITUSI DIGRAFIK) ---
# Cipher ini bekerja dengan mengganti pasangan huruf (digraf) menggunakan
# sebuah matriks 5x5 yang dibuat dari kunci.
def playfair_process(digraphs: list[str], key: str, mode: str) -> str:
    """Fungsi untuk enkripsi dan dekripsi Playfair dari teks yang sudah disiapkan."""
    # Langkah A: Persiapan Matriks Kunci 5x5
    alphabet = "ABCDEFGHIKLMNOPQRSTUVWXYZ"
    key_clean = "".join(OrderedDict.fromkeys(key.upper().replace('J', 'I')))
    matrix_str = key_clean + "".join([c for c in alphabet if c not in key_clean])
    matrix = [list(matrix_str[i:i+5]) for i in range(0, 25, 5)]
    coords_map = {char: (r, c) for r, row in enumerate(matrix) for c, char in enumerate(row)}

    result = []
    shift = 1 if mode == 'encrypt' else -1

    # Langkah B: Proses Enkripsi/Dekripsi berdasarkan 3 Aturan Playfair
    for d in digraphs:
        if len(d) != 2 or d[0] not in coords_map or d[1] not in coords_map:
            continue
        r1, c1 = coords_map[d[0]]
        r2, c2 = coords_map[d[1]]
        
        if r1 == r2: # Aturan 1: Baris sama, geser kolom
            result.append(matrix[r1][(c1 + shift) % 5] + matrix[r2][(c2 + shift) % 5])
        elif c1 == c2: # Aturan 2: Kolom sama, geser baris
            result.append(matrix[(r1 + shift) % 5][c1] + matrix[(r2 + shift) % 5][c2])
        else: # Aturan 3: Membentuk persegi, tukar kolom
            result.append(matrix[r1][c2] + matrix[r2][c1])
            
    return "".join(result)


# --- 3. CAESAR CIPHER (CIPHER GESER) ---
# Cipher klasik paling sederhana. Setiap huruf digeser maju/mundur
# di alfabet berdasarkan kunci angka.
def caesar_process(text: str, key: int, mode: str) -> str:
    """Fungsi untuk enkripsi dan dekripsi Caesar."""
    shift = key if mode == 'encrypt' else -key
    result = ""
    for char in text.upper():
        if 'A' <= char <= 'Z':
            result += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))
        else:
            result += char
    return result


# --- 4. AES (CIPHER BLOK MODERN) ---
# Standar enkripsi modern yang sangat kuat. Bekerja pada blok data 16-byte.
# Kode ini menggunakan mode ECB (Electronic Codebook).
def aes_process(text: str, key: str, mode: str) -> str | None:
    """Fungsi untuk enkripsi dan dekripsi AES-128 dalam mode ECB."""
    try:
        key_bytes = hashlib.sha256(key.encode()).digest()[:16]
        cipher = AES.new(key_bytes, AES.MODE_ECB)

        if mode == 'encrypt':
            data_bytes = text.encode('utf-8')
            encrypted_bytes = cipher.encrypt(pad(data_bytes, AES.block_size))
            return base64.b64encode(encrypted_bytes).decode('utf-8')
        else:
            data_bytes = base64.b64decode(text)
            decrypted_bytes = cipher.decrypt(data_bytes)
            return unpad(decrypted_bytes, AES.block_size).decode('utf-8')
    except (ValueError, KeyError):
        return None

# ==============================================================================
# BAGIAN 2: APLIKASI GUI (User Interface)
# ==============================================================================

class ChainedCipherApp(customtkinter.CTk):
    def __init__(self):
        super().__init__()
        self.title("Kriptografi Berlapis: Playfair, Caesar & AES")
        self.geometry("800x700")
        customtkinter.set_appearance_mode("dark")

        main_frame = customtkinter.CTkScrollableFrame(self, fg_color="transparent")
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)

        customtkinter.CTkLabel(main_frame, text="Cipher Berlapis", font=("Inter", 32, "bold")).pack(pady=(10, 20))

        input_card = customtkinter.CTkFrame(main_frame, corner_radius=15)
        input_card.pack(fill="x", padx=10, pady=10)
        customtkinter.CTkLabel(input_card, text="Teks & Kunci", font=("Inter", 18, "bold")).pack(pady=(15, 10))
        
        self.text_entry = customtkinter.CTkEntry(input_card, placeholder_text="Masukkan Teks Anda", height=45)
        self.playfair_key_entry = customtkinter.CTkEntry(input_card, placeholder_text="Kunci Playfair (e.g., MONARCHY)", height=45)
        self.caesar_key_entry = customtkinter.CTkEntry(input_card, placeholder_text="Kunci Caesar (e.g., 3)", height=45)
        self.aes_key_entry = customtkinter.CTkEntry(input_card, placeholder_text="Kunci AES (e.g., kunciRahasia123)", height=45)
        
        for widget in [self.text_entry, self.playfair_key_entry, self.caesar_key_entry, self.aes_key_entry]:
            widget.pack(fill="x", padx=15, pady=5)
        self.aes_key_entry.pack(pady=(5, 20))

        button_frame = customtkinter.CTkFrame(main_frame, fg_color="transparent")
        button_frame.pack(fill="x", padx=10, pady=10)
        encrypt_button = customtkinter.CTkButton(button_frame, text="ðŸ”’ Enkripsi", command=lambda: self.run_process('encrypt'), height=50)
        decrypt_button = customtkinter.CTkButton(button_frame, text="ðŸ”“ Dekripsi", command=lambda: self.run_process('decrypt'), height=50)
        encrypt_button.pack(side="left", expand=True, padx=5)
        decrypt_button.pack(side="right", expand=True, padx=5)

        result_card = customtkinter.CTkFrame(main_frame, corner_radius=15)
        result_card.pack(fill="x", padx=10, pady=10)
        customtkinter.CTkLabel(result_card, text="Hasil Proses", font=("Inter", 18, "bold")).pack(pady=(15, 10))
        self.result_label = customtkinter.CTkLabel(result_card, text="", font=("Courier New", 14), wraplength=700, justify="left", corner_radius=10, fg_color="#242424")
        self.result_label.pack(fill="x", padx=15, pady=(0, 15), ipady=15)

    def run_process(self, mode):
        input_text = self.text_entry.get()
        playfair_key = self.playfair_key_entry.get()
        caesar_key_str = self.caesar_key_entry.get()
        aes_key = self.aes_key_entry.get()

        if not all([input_text, playfair_key, caesar_key_str, aes_key]):
            messagebox.showerror("Error", "Semua kolom harus diisi.")
            return
        
        try:
            caesar_key = int(caesar_key_str)
        except ValueError:
            messagebox.showerror("Error", "Kunci Caesar harus berupa angka.")
            return

        try:
            if mode == 'encrypt':
                # === ALUR ENKRIPSI BARU ===
                # LANGKAH 1 (PERSIAPAN): Teks asli diformat untuk Playfair.
                prepared_text = prepare_playfair_text(input_text)
                
                # LANGKAH 2 (PLAYFAIR): Teks yang sudah disiapkan dienkripsi.
                playfair_res = playfair_process(prepared_text, playfair_key, 'encrypt')
                
                # LANGKAH 3 (CAESAR): Hasil Playfair dienkripsi lagi.
                caesar_res = caesar_process(playfair_res, caesar_key, 'encrypt')
                
                # LANGKAH 4 (AES): Hasil Caesar dienkripsi terakhir.
                final_result = aes_process(caesar_res, aes_key, 'encrypt')
            else: # mode == 'decrypt'
                # === ALUR DEKRIPSI (URUTAN DIBALIK) ===
                # LANGKAH 1 (AES): Membuka lapisan terluar.
                aes_res = aes_process(input_text, aes_key, 'decrypt')
                
                if aes_res is None:
                    final_result = "DEKRIPSI GAGAL: Kunci AES salah atau data rusak."
                else:
                    # LANGKAH 2 (CAESAR): Membuka lapisan Caesar.
                    caesar_res = caesar_process(aes_res, caesar_key, 'decrypt')
                    
                    # LANGKAH 3 (PLAYFAIR): Membuka lapisan Playfair.
                    # Teks hasil dekripsi Caesar dipecah manual menjadi pasangan huruf.
                    playfair_digraphs = [caesar_res[i:i+2] for i in range(0, len(caesar_res), 2)]
                    final_result = playfair_process(playfair_digraphs, playfair_key, 'decrypt')
            
            self.result_label.configure(text=final_result)
        except Exception as e:
            messagebox.showerror("Error", f"Terjadi kesalahan tak terduga: {e}")

if __name__ == "__main__":
    app = ChainedCipherApp()
    app.mainloop()
